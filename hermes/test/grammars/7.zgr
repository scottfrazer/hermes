grammar {
  parser<ll1> {
    $start = list($sub, :comma)
    $sub = $item
    $sub = $e
    $item = :b
    $item = :a
    $type_name = :int
    $type_name = :char
    $comma_opt = :comma
    $comma_opt = :_empty
    $initializer_list_item = :item
    $e = parser<expression> {
      (*:left) $e = $e :add $e
      (-:left) $e = $e :subtract $e
      (*:left) $e = $e :multiply $e
      (-:left) $e = $e :divide $e
      (*:left) $e = :lparen_cast $type_name :rparen <=> :lbrace list($initializer_list_item, :comma) $comma_opt :rbrace -> TypeInitializion( type=$1, initializer=$4 )
      (-:left) $e = :identifier <=> :lparen list($e, :comma) :rparen -> FunctionCall( name=$$, params=$2 )
      (*:unary) $e = :subtract $e
      $e = :lsquare list($e, :comma) :rsquare
      $e = :lbrace list($e, :comma) :rbrace
      $e = :lparen $e :rparen
      $e = :identifier
      $e = :number
    }
  }
}
